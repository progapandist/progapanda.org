{"id":"../node_modules/xterm/lib/Linkifier.js","dependencies":[{"name":"/Users/andybarnov/code/progapandist/rnd/webterm/node_modules/xterm/lib/Linkifier.js.map","includedInParent":true,"mtime":1587222920480},{"name":"/Users/andybarnov/code/progapandist/rnd/webterm/node_modules/xterm/src/Linkifier.ts","includedInParent":true,"mtime":1587222920480},{"name":"/Users/andybarnov/code/progapandist/rnd/webterm/package.json","includedInParent":true,"mtime":1587223993374},{"name":"/Users/andybarnov/code/progapandist/rnd/webterm/node_modules/xterm/package.json","includedInParent":true,"mtime":1586604134482}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar INVALID_LINK_CLASS = 'xterm-invalid-link';\nvar protocolClause = '(https?:\\\\/\\\\/)';\nvar domainCharacterSet = '[\\\\da-z\\\\.-]+';\nvar negatedDomainCharacterSet = '[^\\\\da-z\\\\.-]+';\nvar domainBodyClause = '(' + domainCharacterSet + ')';\nvar tldClause = '([a-z\\\\.]{2,6})';\nvar ipClause = '((\\\\d{1,3}\\\\.){3}\\\\d{1,3})';\nvar localHostClause = '(localhost)';\nvar portClause = '(:\\\\d{1,5})';\nvar hostClause = '((' + domainBodyClause + '\\\\.' + tldClause + ')|' + ipClause + '|' + localHostClause + ')' + portClause + '?';\nvar pathClause = '(\\\\/[\\\\/\\\\w\\\\.\\\\-%~]*)*';\nvar queryStringHashFragmentCharacterSet = '[0-9\\\\w\\\\[\\\\]\\\\(\\\\)\\\\/\\\\?\\\\!#@$%&\\'*+,:;~\\\\=\\\\.\\\\-]*';\nvar queryStringClause = '(\\\\?' + queryStringHashFragmentCharacterSet + ')?';\nvar hashFragmentClause = '(#' + queryStringHashFragmentCharacterSet + ')?';\nvar negatedPathCharacterSet = '[^\\\\/\\\\w\\\\.\\\\-%]+';\nvar bodyClause = hostClause + pathClause + queryStringClause + hashFragmentClause;\nvar start = '(?:^|' + negatedDomainCharacterSet + ')(';\nvar end = ')($|' + negatedPathCharacterSet + ')';\nvar strictUrlRegex = new RegExp(start + protocolClause + bodyClause + end);\nvar HYPERTEXT_LINK_MATCHER_ID = 0;\nvar Linkifier = (function () {\n    function Linkifier() {\n        this._nextLinkMatcherId = HYPERTEXT_LINK_MATCHER_ID;\n        this._rowTimeoutIds = [];\n        this._linkMatchers = [];\n        this.registerLinkMatcher(strictUrlRegex, null, { matchIndex: 1 });\n    }\n    Linkifier.prototype.attachToDom = function (document, rows) {\n        this._document = document;\n        this._rows = rows;\n    };\n    Linkifier.prototype.linkifyRow = function (rowIndex) {\n        if (!this._document) {\n            return;\n        }\n        var timeoutId = this._rowTimeoutIds[rowIndex];\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n        }\n        this._rowTimeoutIds[rowIndex] = setTimeout(this._linkifyRow.bind(this, rowIndex), Linkifier.TIME_BEFORE_LINKIFY);\n    };\n    Linkifier.prototype.setHypertextLinkHandler = function (handler) {\n        this._linkMatchers[HYPERTEXT_LINK_MATCHER_ID].handler = handler;\n    };\n    Linkifier.prototype.setHypertextValidationCallback = function (callback) {\n        this._linkMatchers[HYPERTEXT_LINK_MATCHER_ID].validationCallback = callback;\n    };\n    Linkifier.prototype.registerLinkMatcher = function (regex, handler, options) {\n        if (options === void 0) { options = {}; }\n        if (this._nextLinkMatcherId !== HYPERTEXT_LINK_MATCHER_ID && !handler) {\n            throw new Error('handler must be defined');\n        }\n        var matcher = {\n            id: this._nextLinkMatcherId++,\n            regex: regex,\n            handler: handler,\n            matchIndex: options.matchIndex,\n            validationCallback: options.validationCallback,\n            priority: options.priority || 0\n        };\n        this._addLinkMatcherToList(matcher);\n        return matcher.id;\n    };\n    Linkifier.prototype._addLinkMatcherToList = function (matcher) {\n        if (this._linkMatchers.length === 0) {\n            this._linkMatchers.push(matcher);\n            return;\n        }\n        for (var i = this._linkMatchers.length - 1; i >= 0; i--) {\n            if (matcher.priority <= this._linkMatchers[i].priority) {\n                this._linkMatchers.splice(i + 1, 0, matcher);\n                return;\n            }\n        }\n        this._linkMatchers.splice(0, 0, matcher);\n    };\n    Linkifier.prototype.deregisterLinkMatcher = function (matcherId) {\n        for (var i = 1; i < this._linkMatchers.length; i++) {\n            if (this._linkMatchers[i].id === matcherId) {\n                this._linkMatchers.splice(i, 1);\n                return true;\n            }\n        }\n        return false;\n    };\n    Linkifier.prototype._linkifyRow = function (rowIndex) {\n        var row = this._rows[rowIndex];\n        if (!row) {\n            return;\n        }\n        var text = row.textContent;\n        for (var i = 0; i < this._linkMatchers.length; i++) {\n            var matcher = this._linkMatchers[i];\n            var linkElements = this._doLinkifyRow(row, matcher);\n            if (linkElements.length > 0) {\n                if (matcher.validationCallback) {\n                    var _loop_1 = function (j) {\n                        var element = linkElements[j];\n                        matcher.validationCallback(element.textContent, element, function (isValid) {\n                            if (!isValid) {\n                                element.classList.add(INVALID_LINK_CLASS);\n                            }\n                        });\n                    };\n                    for (var j = 0; j < linkElements.length; j++) {\n                        _loop_1(j);\n                    }\n                }\n                return;\n            }\n        }\n    };\n    Linkifier.prototype._doLinkifyRow = function (row, matcher) {\n        var result = [];\n        var isHttpLinkMatcher = matcher.id === HYPERTEXT_LINK_MATCHER_ID;\n        var nodes = row.childNodes;\n        var match = row.textContent.match(matcher.regex);\n        if (!match || match.length === 0) {\n            return result;\n        }\n        var uri = match[typeof matcher.matchIndex !== 'number' ? 0 : matcher.matchIndex];\n        var rowStartIndex = match.index + uri.length;\n        for (var i = 0; i < nodes.length; i++) {\n            var node = nodes[i];\n            var searchIndex = node.textContent.indexOf(uri);\n            if (searchIndex >= 0) {\n                var linkElement = this._createAnchorElement(uri, matcher.handler, isHttpLinkMatcher);\n                if (node.textContent.length === uri.length) {\n                    if (node.nodeType === 3) {\n                        this._replaceNode(node, linkElement);\n                    }\n                    else {\n                        var element = node;\n                        if (element.nodeName === 'A') {\n                            return result;\n                        }\n                        element.innerHTML = '';\n                        element.appendChild(linkElement);\n                    }\n                }\n                else {\n                    var nodesAdded = this._replaceNodeSubstringWithNode(node, linkElement, uri, searchIndex);\n                    i += nodesAdded;\n                }\n                result.push(linkElement);\n                match = row.textContent.substring(rowStartIndex).match(matcher.regex);\n                if (!match || match.length === 0) {\n                    return result;\n                }\n                uri = match[typeof matcher.matchIndex !== 'number' ? 0 : matcher.matchIndex];\n                rowStartIndex += match.index + uri.length;\n            }\n        }\n        return result;\n    };\n    Linkifier.prototype._createAnchorElement = function (uri, handler, isHypertextLinkHandler) {\n        var element = this._document.createElement('a');\n        element.textContent = uri;\n        element.draggable = false;\n        if (isHypertextLinkHandler) {\n            element.href = uri;\n            element.target = '_blank';\n            element.addEventListener('click', function (event) {\n                if (handler) {\n                    return handler(event, uri);\n                }\n            });\n        }\n        else {\n            element.addEventListener('click', function (event) {\n                if (element.classList.contains(INVALID_LINK_CLASS)) {\n                    return;\n                }\n                return handler(event, uri);\n            });\n        }\n        return element;\n    };\n    Linkifier.prototype._replaceNode = function (oldNode) {\n        var newNodes = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            newNodes[_i - 1] = arguments[_i];\n        }\n        var parent = oldNode.parentNode;\n        for (var i = 0; i < newNodes.length; i++) {\n            parent.insertBefore(newNodes[i], oldNode);\n        }\n        parent.removeChild(oldNode);\n    };\n    Linkifier.prototype._replaceNodeSubstringWithNode = function (targetNode, newNode, substring, substringIndex) {\n        var node = targetNode;\n        if (node.nodeType !== 3) {\n            node = node.childNodes[0];\n        }\n        if (node.childNodes.length === 0 && node.nodeType !== 3) {\n            throw new Error('targetNode must be a text node or only contain a single text node');\n        }\n        var fullText = node.textContent;\n        if (substringIndex === 0) {\n            var rightText_1 = fullText.substring(substring.length);\n            var rightTextNode_1 = this._document.createTextNode(rightText_1);\n            this._replaceNode(node, newNode, rightTextNode_1);\n            return 0;\n        }\n        if (substringIndex === targetNode.textContent.length - substring.length) {\n            var leftText_1 = fullText.substring(0, substringIndex);\n            var leftTextNode_1 = this._document.createTextNode(leftText_1);\n            this._replaceNode(node, leftTextNode_1, newNode);\n            return 0;\n        }\n        var leftText = fullText.substring(0, substringIndex);\n        var leftTextNode = this._document.createTextNode(leftText);\n        var rightText = fullText.substring(substringIndex + substring.length);\n        var rightTextNode = this._document.createTextNode(rightText);\n        this._replaceNode(node, leftTextNode, newNode, rightTextNode);\n        return 1;\n    };\n    return Linkifier;\n}());\nLinkifier.TIME_BEFORE_LINKIFY = 200;\nexports.Linkifier = Linkifier;\n\n\n"},"sourceMaps":{"js":{"version":3,"sources":["../src/Linkifier.ts"],"names":[],"mappings":"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","file":"Linkifier.js","sourceRoot":".","sourcesContent":["/**\n * @license MIT\n */\n\nimport { LinkMatcherOptions } from './Interfaces';\nimport { LinkMatcher, LinkMatcherHandler, LinkMatcherValidationCallback } from './Types';\n\nconst INVALID_LINK_CLASS = 'xterm-invalid-link';\n\nconst protocolClause = '(https?:\\\\/\\\\/)';\nconst domainCharacterSet = '[\\\\da-z\\\\.-]+';\nconst negatedDomainCharacterSet = '[^\\\\da-z\\\\.-]+';\nconst domainBodyClause = '(' + domainCharacterSet + ')';\nconst tldClause = '([a-z\\\\.]{2,6})';\nconst ipClause = '((\\\\d{1,3}\\\\.){3}\\\\d{1,3})';\nconst localHostClause = '(localhost)';\nconst portClause = '(:\\\\d{1,5})';\nconst hostClause = '((' + domainBodyClause + '\\\\.' + tldClause + ')|' + ipClause + '|' + localHostClause + ')' + portClause + '?';\nconst pathClause = '(\\\\/[\\\\/\\\\w\\\\.\\\\-%~]*)*';\nconst queryStringHashFragmentCharacterSet = '[0-9\\\\w\\\\[\\\\]\\\\(\\\\)\\\\/\\\\?\\\\!#@$%&\\'*+,:;~\\\\=\\\\.\\\\-]*';\nconst queryStringClause = '(\\\\?' + queryStringHashFragmentCharacterSet + ')?';\nconst hashFragmentClause = '(#' + queryStringHashFragmentCharacterSet + ')?';\nconst negatedPathCharacterSet = '[^\\\\/\\\\w\\\\.\\\\-%]+';\nconst bodyClause = hostClause + pathClause + queryStringClause + hashFragmentClause;\nconst start = '(?:^|' + negatedDomainCharacterSet + ')(';\nconst end = ')($|' + negatedPathCharacterSet + ')';\nconst strictUrlRegex = new RegExp(start + protocolClause + bodyClause + end);\n\n/**\n * The ID of the built in http(s) link matcher.\n */\nconst HYPERTEXT_LINK_MATCHER_ID = 0;\n\n/**\n * The Linkifier applies links to rows shortly after they have been refreshed.\n */\nexport class Linkifier {\n  /**\n   * The time to wait after a row is changed before it is linkified. This prevents\n   * the costly operation of searching every row multiple times, potentially a\n   * huge amount of times.\n   */\n  protected static TIME_BEFORE_LINKIFY = 200;\n\n  protected _linkMatchers: LinkMatcher[];\n\n  private _document: Document;\n  private _rows: HTMLElement[];\n  private _rowTimeoutIds: number[];\n  private _nextLinkMatcherId = HYPERTEXT_LINK_MATCHER_ID;\n\n  constructor() {\n    this._rowTimeoutIds = [];\n    this._linkMatchers = [];\n    this.registerLinkMatcher(strictUrlRegex, null, { matchIndex: 1 });\n  }\n\n  /**\n   * Attaches the linkifier to the DOM, enabling linkification.\n   * @param document The document object.\n   * @param rows The array of rows to apply links to.\n   */\n  public attachToDom(document: Document, rows: HTMLElement[]) {\n    this._document = document;\n    this._rows = rows;\n  }\n\n  /**\n   * Queues a row for linkification.\n   * @param {number} rowIndex The index of the row to linkify.\n   */\n  public linkifyRow(rowIndex: number): void {\n    // Don't attempt linkify if not yet attached to DOM\n    if (!this._document) {\n      return;\n    }\n\n    const timeoutId = this._rowTimeoutIds[rowIndex];\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n    this._rowTimeoutIds[rowIndex] = setTimeout(this._linkifyRow.bind(this, rowIndex), Linkifier.TIME_BEFORE_LINKIFY);\n  }\n\n  /**\n   * Attaches a handler for hypertext links, overriding default <a> behavior\n   * for standard http(s) links.\n   * @param {LinkHandler} handler The handler to use, this can be cleared with\n   * null.\n   */\n  public setHypertextLinkHandler(handler: LinkMatcherHandler): void {\n    this._linkMatchers[HYPERTEXT_LINK_MATCHER_ID].handler = handler;\n  }\n\n  /**\n   * Attaches a validation callback for hypertext links.\n   * @param {LinkMatcherValidationCallback} callback The callback to use, this\n   * can be cleared with null.\n   */\n  public setHypertextValidationCallback(callback: LinkMatcherValidationCallback): void {\n    this._linkMatchers[HYPERTEXT_LINK_MATCHER_ID].validationCallback = callback;\n  }\n\n  /**\n   * Registers a link matcher, allowing custom link patterns to be matched and\n   * handled.\n   * @param {RegExp} regex The regular expression to search for, specifically\n   * this searches the textContent of the rows. You will want to use \\s to match\n   * a space ' ' character for example.\n   * @param {LinkHandler} handler The callback when the link is called.\n   * @param {LinkMatcherOptions} [options] Options for the link matcher.\n   * @return {number} The ID of the new matcher, this can be used to deregister.\n   */\n  public registerLinkMatcher(regex: RegExp, handler: LinkMatcherHandler, options: LinkMatcherOptions = {}): number {\n    if (this._nextLinkMatcherId !== HYPERTEXT_LINK_MATCHER_ID && !handler) {\n      throw new Error('handler must be defined');\n    }\n    const matcher: LinkMatcher = {\n      id: this._nextLinkMatcherId++,\n      regex,\n      handler,\n      matchIndex: options.matchIndex,\n      validationCallback: options.validationCallback,\n      priority: options.priority || 0\n    };\n    this._addLinkMatcherToList(matcher);\n    return matcher.id;\n  }\n\n  /**\n   * Inserts a link matcher to the list in the correct position based on the\n   * priority of each link matcher. New link matchers of equal priority are\n   * considered after older link matchers.\n   * @param matcher The link matcher to be added.\n   */\n  private _addLinkMatcherToList(matcher: LinkMatcher): void {\n    if (this._linkMatchers.length === 0) {\n      this._linkMatchers.push(matcher);\n      return;\n    }\n\n    for (let i = this._linkMatchers.length - 1; i >= 0; i--) {\n      if (matcher.priority <= this._linkMatchers[i].priority) {\n        this._linkMatchers.splice(i + 1, 0, matcher);\n        return;\n      }\n    }\n\n    this._linkMatchers.splice(0, 0, matcher);\n  }\n\n  /**\n   * Deregisters a link matcher if it has been registered.\n   * @param {number} matcherId The link matcher's ID (returned after register)\n   * @return {boolean} Whether a link matcher was found and deregistered.\n   */\n  public deregisterLinkMatcher(matcherId: number): boolean {\n    // ID 0 is the hypertext link matcher which cannot be deregistered\n    for (let i = 1; i < this._linkMatchers.length; i++) {\n      if (this._linkMatchers[i].id === matcherId) {\n        this._linkMatchers.splice(i, 1);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Linkifies a row.\n   * @param {number} rowIndex The index of the row to linkify.\n   */\n  private _linkifyRow(rowIndex: number): void {\n    const row = this._rows[rowIndex];\n    if (!row) {\n      return;\n    }\n    const text = row.textContent;\n    for (let i = 0; i < this._linkMatchers.length; i++) {\n      const matcher = this._linkMatchers[i];\n      const linkElements = this._doLinkifyRow(row, matcher);\n        if (linkElements.length > 0) {\n        // Fire validation callback\n        if (matcher.validationCallback) {\n          for (let j = 0; j < linkElements.length; j++) {\n            const element = linkElements[j];\n            matcher.validationCallback(element.textContent, element, isValid => {\n              if (!isValid) {\n                element.classList.add(INVALID_LINK_CLASS);\n              }\n            });\n          }\n        }\n        // Only allow a single LinkMatcher to trigger on any given row.\n        return;\n      }\n    }\n  }\n\n  /**\n   * Linkifies a row given a specific handler.\n   * @param {HTMLElement} row The row to linkify.\n   * @param {LinkMatcher} matcher The link matcher for this line.\n   * @return The link element if it was added, otherwise undefined.\n   */\n  private _doLinkifyRow(row: HTMLElement, matcher: LinkMatcher): HTMLElement[] {\n    // Iterate over nodes as we want to consider text nodes\n    let result = [];\n    const isHttpLinkMatcher = matcher.id === HYPERTEXT_LINK_MATCHER_ID;\n    const nodes = row.childNodes;\n\n    // Find the first match\n    let match = row.textContent.match(matcher.regex);\n    if (!match || match.length === 0) {\n      return result;\n    }\n    let uri = match[typeof matcher.matchIndex !== 'number' ? 0 : matcher.matchIndex];\n    // Set the next searches start index\n    let rowStartIndex = match.index + uri.length;\n\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      const searchIndex = node.textContent.indexOf(uri);\n      if (searchIndex >= 0) {\n        const linkElement = this._createAnchorElement(uri, matcher.handler, isHttpLinkMatcher);\n        if (node.textContent.length === uri.length) {\n          // Matches entire string\n          if (node.nodeType === 3 /*Node.TEXT_NODE*/) {\n            this._replaceNode(node, linkElement);\n          } else {\n            const element = (<HTMLElement>node);\n            if (element.nodeName === 'A') {\n              // This row has already been linkified\n              return result;\n            }\n            element.innerHTML = '';\n            element.appendChild(linkElement);\n          }\n        } else {\n          // Matches part of string\n          const nodesAdded = this._replaceNodeSubstringWithNode(node, linkElement, uri, searchIndex);\n          // No need to consider the new nodes\n          i += nodesAdded;\n        }\n        result.push(linkElement);\n\n        // Find the next match\n        match = row.textContent.substring(rowStartIndex).match(matcher.regex);\n        if (!match || match.length === 0) {\n          return result;\n        }\n        uri = match[typeof matcher.matchIndex !== 'number' ? 0 : matcher.matchIndex];\n        rowStartIndex += match.index + uri.length;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Creates a link anchor element.\n   * @param {string} uri The uri of the link.\n   * @return {HTMLAnchorElement} The link.\n   */\n  private _createAnchorElement(uri: string, handler: LinkMatcherHandler, isHypertextLinkHandler: boolean): HTMLAnchorElement {\n    const element = this._document.createElement('a');\n    element.textContent = uri;\n    element.draggable = false;\n    if (isHypertextLinkHandler) {\n      element.href = uri;\n      // Force link on another tab so work is not lost\n      element.target = '_blank';\n      element.addEventListener('click', (event: MouseEvent) => {\n        if (handler) {\n          return handler(event, uri);\n        }\n      });\n    } else {\n      element.addEventListener('click', (event: MouseEvent) => {\n        // Don't execute the handler if the link is flagged as invalid\n        if (element.classList.contains(INVALID_LINK_CLASS)) {\n          return;\n        }\n        return handler(event, uri);\n      });\n    }\n    return element;\n  }\n\n  /**\n   * Replace a node with 1 or more other nodes.\n   * @param {Node} oldNode The node to replace.\n   * @param {Node[]} newNodes The new nodes to insert in order.\n   */\n  private _replaceNode(oldNode: Node, ...newNodes: Node[]): void {\n    const parent = oldNode.parentNode;\n    for (let i = 0; i < newNodes.length; i++) {\n      parent.insertBefore(newNodes[i], oldNode);\n    }\n    parent.removeChild(oldNode);\n  }\n\n  /**\n   * Replace a substring within a node with a new node.\n   * @param {Node} targetNode The target node; either a text node or a <span>\n   * containing a single text node.\n   * @param {Node} newNode The new node to insert.\n   * @param {string} substring The substring to replace.\n   * @param {number} substringIndex The index of the substring within the string.\n   * @return The number of nodes to skip when searching for the next uri.\n   */\n  private _replaceNodeSubstringWithNode(targetNode: Node, newNode: Node, substring: string, substringIndex: number): number {\n    let node = targetNode;\n    if (node.nodeType !== 3/*Node.TEXT_NODE*/) {\n      node = node.childNodes[0];\n    }\n\n    // The targetNode will be either a text node or a <span>. The text node\n    // (targetNode or its only-child) needs to be replaced with newNode plus new\n    // text nodes potentially on either side.\n    if (node.childNodes.length === 0 && node.nodeType !== 3/*Node.TEXT_NODE*/) {\n      throw new Error('targetNode must be a text node or only contain a single text node');\n    }\n\n    const fullText = node.textContent;\n\n    if (substringIndex === 0) {\n      // Replace with <newNode><textnode>\n      const rightText = fullText.substring(substring.length);\n      const rightTextNode = this._document.createTextNode(rightText);\n      this._replaceNode(node, newNode, rightTextNode);\n      return 0;\n    }\n\n    if (substringIndex === targetNode.textContent.length - substring.length) {\n      // Replace with <textnode><newNode>\n      const leftText = fullText.substring(0, substringIndex);\n      const leftTextNode = this._document.createTextNode(leftText);\n      this._replaceNode(node, leftTextNode, newNode);\n      return 0;\n    }\n\n    // Replace with <textnode><newNode><textnode>\n    const leftText = fullText.substring(0, substringIndex);\n    const leftTextNode = this._document.createTextNode(leftText);\n    const rightText = fullText.substring(substringIndex + substring.length);\n    const rightTextNode = this._document.createTextNode(rightText);\n    this._replaceNode(node, leftTextNode, newNode, rightTextNode);\n    return 1;\n  }\n}\n"]}},"error":null,"hash":"bfdf211ea490675f0ed645450b8d74e9","cacheData":{"env":{}}}