{"id":"../node_modules/xterm/lib/SelectionManager.js","dependencies":[{"name":"/Users/andybarnov/code/progapandist/rnd/webterm/node_modules/xterm/lib/SelectionManager.js.map","includedInParent":true,"mtime":1587220294442},{"name":"/Users/andybarnov/code/progapandist/rnd/webterm/node_modules/xterm/src/SelectionManager.ts","includedInParent":true,"mtime":1587220294442},{"name":"/Users/andybarnov/code/progapandist/rnd/webterm/package.json","includedInParent":true,"mtime":1587222475840},{"name":"/Users/andybarnov/code/progapandist/rnd/webterm/node_modules/xterm/package.json","includedInParent":true,"mtime":1587220294442},{"name":"./utils/Mouse","loc":{"line":13,"column":20},"parent":"/Users/andybarnov/code/progapandist/rnd/webterm/node_modules/xterm/lib/SelectionManager.js","resolved":"/Users/andybarnov/code/progapandist/rnd/webterm/node_modules/xterm/lib/utils/Mouse.js"},{"name":"./utils/Browser","loc":{"line":14,"column":22},"parent":"/Users/andybarnov/code/progapandist/rnd/webterm/node_modules/xterm/lib/SelectionManager.js","resolved":"/Users/andybarnov/code/progapandist/rnd/webterm/node_modules/xterm/lib/utils/Browser.js"},{"name":"./EventEmitter","loc":{"line":15,"column":29},"parent":"/Users/andybarnov/code/progapandist/rnd/webterm/node_modules/xterm/lib/SelectionManager.js","resolved":"/Users/andybarnov/code/progapandist/rnd/webterm/node_modules/xterm/lib/EventEmitter.js"},{"name":"./SelectionModel","loc":{"line":16,"column":31},"parent":"/Users/andybarnov/code/progapandist/rnd/webterm/node_modules/xterm/lib/SelectionManager.js","resolved":"/Users/andybarnov/code/progapandist/rnd/webterm/node_modules/xterm/lib/SelectionModel.js"}],"generated":{"js":"\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Mouse = require(\"./utils/Mouse\");\nvar Browser = require(\"./utils/Browser\");\nvar EventEmitter_1 = require(\"./EventEmitter\");\nvar SelectionModel_1 = require(\"./SelectionModel\");\nvar DRAG_SCROLL_MAX_THRESHOLD = 50;\nvar DRAG_SCROLL_MAX_SPEED = 15;\nvar DRAG_SCROLL_INTERVAL = 50;\nvar CLEAR_MOUSE_DOWN_TIME = 400;\nvar CLEAR_MOUSE_DISTANCE = 10;\nvar WORD_SEPARATORS = ' ()[]{}\\'\"';\nvar LINE_DATA_CHAR_INDEX = 1;\nvar LINE_DATA_WIDTH_INDEX = 2;\nvar NON_BREAKING_SPACE_CHAR = String.fromCharCode(160);\nvar ALL_NON_BREAKING_SPACE_REGEX = new RegExp(NON_BREAKING_SPACE_CHAR, 'g');\nvar SelectionMode;\n(function (SelectionMode) {\n    SelectionMode[SelectionMode[\"NORMAL\"] = 0] = \"NORMAL\";\n    SelectionMode[SelectionMode[\"WORD\"] = 1] = \"WORD\";\n    SelectionMode[SelectionMode[\"LINE\"] = 2] = \"LINE\";\n})(SelectionMode || (SelectionMode = {}));\nvar SelectionManager = (function (_super) {\n    __extends(SelectionManager, _super);\n    function SelectionManager(_terminal, _buffer, _rowContainer, _charMeasure) {\n        var _this = _super.call(this) || this;\n        _this._terminal = _terminal;\n        _this._buffer = _buffer;\n        _this._rowContainer = _rowContainer;\n        _this._charMeasure = _charMeasure;\n        _this._initListeners();\n        _this.enable();\n        _this._model = new SelectionModel_1.SelectionModel(_terminal);\n        _this._lastMouseDownTime = 0;\n        _this._activeSelectionMode = SelectionMode.NORMAL;\n        return _this;\n    }\n    SelectionManager.prototype._initListeners = function () {\n        var _this = this;\n        this._bufferTrimListener = function (amount) { return _this._onTrim(amount); };\n        this._mouseMoveListener = function (event) { return _this._onMouseMove(event); };\n        this._mouseDownListener = function (event) { return _this._onMouseDown(event); };\n        this._mouseUpListener = function (event) { return _this._onMouseUp(event); };\n    };\n    SelectionManager.prototype.disable = function () {\n        this.clearSelection();\n        this._buffer.off('trim', this._bufferTrimListener);\n        this._rowContainer.removeEventListener('mousedown', this._mouseDownListener);\n    };\n    SelectionManager.prototype.enable = function () {\n        this._buffer.on('trim', this._bufferTrimListener);\n        this._rowContainer.addEventListener('mousedown', this._mouseDownListener);\n    };\n    SelectionManager.prototype.setBuffer = function (buffer) {\n        this._buffer = buffer;\n        this.clearSelection();\n    };\n    Object.defineProperty(SelectionManager.prototype, \"hasSelection\", {\n        get: function () {\n            var start = this._model.finalSelectionStart;\n            var end = this._model.finalSelectionEnd;\n            if (!start || !end) {\n                return false;\n            }\n            return start[0] !== end[0] || start[1] !== end[1];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SelectionManager.prototype, \"selectionText\", {\n        get: function () {\n            var start = this._model.finalSelectionStart;\n            var end = this._model.finalSelectionEnd;\n            if (!start || !end) {\n                return '';\n            }\n            var startRowEndCol = start[1] === end[1] ? end[0] : null;\n            var result = [];\n            result.push(this._translateBufferLineToString(this._buffer.get(start[1]), true, start[0], startRowEndCol));\n            for (var i = start[1] + 1; i <= end[1] - 1; i++) {\n                var bufferLine = this._buffer.get(i);\n                var lineText = this._translateBufferLineToString(bufferLine, true);\n                if (bufferLine.isWrapped) {\n                    result[result.length - 1] += lineText;\n                }\n                else {\n                    result.push(lineText);\n                }\n            }\n            if (start[1] !== end[1]) {\n                var bufferLine = this._buffer.get(end[1]);\n                var lineText = this._translateBufferLineToString(bufferLine, true, 0, end[0]);\n                if (bufferLine.isWrapped) {\n                    result[result.length - 1] += lineText;\n                }\n                else {\n                    result.push(lineText);\n                }\n            }\n            var formattedResult = result.map(function (line) {\n                return line.replace(ALL_NON_BREAKING_SPACE_REGEX, ' ');\n            }).join(Browser.isMSWindows ? '\\r\\n' : '\\n');\n            return formattedResult;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SelectionManager.prototype.clearSelection = function () {\n        this._model.clearSelection();\n        this._removeMouseDownListeners();\n        this.refresh();\n    };\n    SelectionManager.prototype._translateBufferLineToString = function (line, trimRight, startCol, endCol) {\n        if (startCol === void 0) { startCol = 0; }\n        if (endCol === void 0) { endCol = null; }\n        var lineString = '';\n        var widthAdjustedStartCol = startCol;\n        var widthAdjustedEndCol = endCol;\n        for (var i = 0; i < line.length; i++) {\n            var char = line[i];\n            lineString += char[LINE_DATA_CHAR_INDEX];\n            if (char[LINE_DATA_WIDTH_INDEX] === 0) {\n                if (startCol >= i) {\n                    widthAdjustedStartCol--;\n                }\n                if (endCol >= i) {\n                    widthAdjustedEndCol--;\n                }\n            }\n        }\n        var finalEndCol = widthAdjustedEndCol || line.length;\n        if (trimRight) {\n            var rightWhitespaceIndex = lineString.search(/\\s+$/);\n            if (rightWhitespaceIndex !== -1) {\n                finalEndCol = Math.min(finalEndCol, rightWhitespaceIndex);\n            }\n            if (finalEndCol <= widthAdjustedStartCol) {\n                return '';\n            }\n        }\n        return lineString.substring(widthAdjustedStartCol, finalEndCol);\n    };\n    SelectionManager.prototype.refresh = function (isNewSelection) {\n        var _this = this;\n        if (!this._refreshAnimationFrame) {\n            this._refreshAnimationFrame = window.requestAnimationFrame(function () { return _this._refresh(); });\n        }\n        if (Browser.isLinux && isNewSelection) {\n            var selectionText = this.selectionText;\n            if (selectionText.length) {\n                this.emit('newselection', this.selectionText);\n            }\n        }\n    };\n    SelectionManager.prototype._refresh = function () {\n        this._refreshAnimationFrame = null;\n        this.emit('refresh', { start: this._model.finalSelectionStart, end: this._model.finalSelectionEnd });\n    };\n    SelectionManager.prototype.selectAll = function () {\n        this._model.isSelectAllActive = true;\n        this.refresh();\n    };\n    SelectionManager.prototype._onTrim = function (amount) {\n        var needsRefresh = this._model.onTrim(amount);\n        if (needsRefresh) {\n            this.refresh();\n        }\n    };\n    SelectionManager.prototype._getMouseBufferCoords = function (event) {\n        var coords = Mouse.getCoords(event, this._rowContainer, this._charMeasure, this._terminal.cols, this._terminal.rows, true);\n        coords[0]--;\n        coords[1]--;\n        coords[1] += this._terminal.ydisp;\n        return coords;\n    };\n    SelectionManager.prototype._getMouseEventScrollAmount = function (event) {\n        var offset = Mouse.getCoordsRelativeToElement(event, this._rowContainer)[1];\n        var terminalHeight = this._terminal.rows * this._charMeasure.height;\n        if (offset >= 0 && offset <= terminalHeight) {\n            return 0;\n        }\n        if (offset > terminalHeight) {\n            offset -= terminalHeight;\n        }\n        offset = Math.min(Math.max(offset, -DRAG_SCROLL_MAX_THRESHOLD), DRAG_SCROLL_MAX_THRESHOLD);\n        offset /= DRAG_SCROLL_MAX_THRESHOLD;\n        return (offset / Math.abs(offset)) + Math.round(offset * (DRAG_SCROLL_MAX_SPEED - 1));\n    };\n    SelectionManager.prototype._onMouseDown = function (event) {\n        if (event.button !== 0) {\n            return;\n        }\n        event.preventDefault();\n        this._dragScrollAmount = 0;\n        this._setMouseClickCount(event);\n        if (event.shiftKey) {\n            this._onShiftClick(event);\n        }\n        else {\n            if (this._clickCount === 1) {\n                this._onSingleClick(event);\n            }\n            else if (this._clickCount === 2) {\n                this._onDoubleClick(event);\n            }\n            else if (this._clickCount === 3) {\n                this._onTripleClick(event);\n            }\n        }\n        this._addMouseDownListeners();\n        this.refresh(true);\n    };\n    SelectionManager.prototype._addMouseDownListeners = function () {\n        var _this = this;\n        this._rowContainer.ownerDocument.addEventListener('mousemove', this._mouseMoveListener);\n        this._rowContainer.ownerDocument.addEventListener('mouseup', this._mouseUpListener);\n        this._dragScrollIntervalTimer = setInterval(function () { return _this._dragScroll(); }, DRAG_SCROLL_INTERVAL);\n    };\n    SelectionManager.prototype._removeMouseDownListeners = function () {\n        this._rowContainer.ownerDocument.removeEventListener('mousemove', this._mouseMoveListener);\n        this._rowContainer.ownerDocument.removeEventListener('mouseup', this._mouseUpListener);\n        clearInterval(this._dragScrollIntervalTimer);\n        this._dragScrollIntervalTimer = null;\n    };\n    SelectionManager.prototype._onShiftClick = function (event) {\n        if (this._model.selectionStart) {\n            this._model.selectionEnd = this._getMouseBufferCoords(event);\n        }\n    };\n    SelectionManager.prototype._onSingleClick = function (event) {\n        this._model.selectionStartLength = 0;\n        this._model.isSelectAllActive = false;\n        this._activeSelectionMode = SelectionMode.NORMAL;\n        this._model.selectionStart = this._getMouseBufferCoords(event);\n        if (this._model.selectionStart) {\n            this._model.selectionEnd = null;\n            var char = this._buffer.get(this._model.selectionStart[1])[this._model.selectionStart[0]];\n            if (char[LINE_DATA_WIDTH_INDEX] === 0) {\n                this._model.selectionStart[0]++;\n            }\n        }\n    };\n    SelectionManager.prototype._onDoubleClick = function (event) {\n        var coords = this._getMouseBufferCoords(event);\n        if (coords) {\n            this._activeSelectionMode = SelectionMode.WORD;\n            this._selectWordAt(coords);\n        }\n    };\n    SelectionManager.prototype._onTripleClick = function (event) {\n        var coords = this._getMouseBufferCoords(event);\n        if (coords) {\n            this._activeSelectionMode = SelectionMode.LINE;\n            this._selectLineAt(coords[1]);\n        }\n    };\n    SelectionManager.prototype._setMouseClickCount = function (event) {\n        var currentTime = (new Date()).getTime();\n        if (currentTime - this._lastMouseDownTime > CLEAR_MOUSE_DOWN_TIME || this._distanceFromLastMousePosition(event) > CLEAR_MOUSE_DISTANCE) {\n            this._clickCount = 0;\n        }\n        this._lastMouseDownTime = currentTime;\n        this._lastMousePosition = [event.pageX, event.pageY];\n        this._clickCount++;\n    };\n    SelectionManager.prototype._distanceFromLastMousePosition = function (event) {\n        var result = Math.max(Math.abs(this._lastMousePosition[0] - event.pageX), Math.abs(this._lastMousePosition[1] - event.pageY));\n        return result;\n    };\n    SelectionManager.prototype._onMouseMove = function (event) {\n        var previousSelectionEnd = this._model.selectionEnd ? [this._model.selectionEnd[0], this._model.selectionEnd[1]] : null;\n        this._model.selectionEnd = this._getMouseBufferCoords(event);\n        if (this._activeSelectionMode === SelectionMode.LINE) {\n            if (this._model.selectionEnd[1] < this._model.selectionStart[1]) {\n                this._model.selectionEnd[0] = 0;\n            }\n            else {\n                this._model.selectionEnd[0] = this._terminal.cols;\n            }\n        }\n        else if (this._activeSelectionMode === SelectionMode.WORD) {\n            this._selectToWordAt(this._model.selectionEnd);\n        }\n        this._dragScrollAmount = this._getMouseEventScrollAmount(event);\n        if (this._dragScrollAmount > 0) {\n            this._model.selectionEnd[0] = this._terminal.cols - 1;\n        }\n        else if (this._dragScrollAmount < 0) {\n            this._model.selectionEnd[0] = 0;\n        }\n        if (this._model.selectionEnd[1] < this._buffer.length) {\n            var char = this._buffer.get(this._model.selectionEnd[1])[this._model.selectionEnd[0]];\n            if (char && char[2] === 0) {\n                this._model.selectionEnd[0]++;\n            }\n        }\n        if (!previousSelectionEnd ||\n            previousSelectionEnd[0] !== this._model.selectionEnd[0] ||\n            previousSelectionEnd[1] !== this._model.selectionEnd[1]) {\n            this.refresh(true);\n        }\n    };\n    SelectionManager.prototype._dragScroll = function () {\n        if (this._dragScrollAmount) {\n            this._terminal.scrollDisp(this._dragScrollAmount, false);\n            if (this._dragScrollAmount > 0) {\n                this._model.selectionEnd = [this._terminal.cols - 1, this._terminal.ydisp + this._terminal.rows];\n            }\n            else {\n                this._model.selectionEnd = [0, this._terminal.ydisp];\n            }\n            this.refresh();\n        }\n    };\n    SelectionManager.prototype._onMouseUp = function (event) {\n        this._removeMouseDownListeners();\n    };\n    SelectionManager.prototype._convertViewportColToCharacterIndex = function (bufferLine, coords) {\n        var charIndex = coords[0];\n        for (var i = 0; coords[0] >= i; i++) {\n            var char = bufferLine[i];\n            if (char[LINE_DATA_WIDTH_INDEX] === 0) {\n                charIndex--;\n            }\n        }\n        return charIndex;\n    };\n    SelectionManager.prototype._getWordAt = function (coords) {\n        var bufferLine = this._buffer.get(coords[1]);\n        var line = this._translateBufferLineToString(bufferLine, false);\n        var endIndex = this._convertViewportColToCharacterIndex(bufferLine, coords);\n        var startIndex = endIndex;\n        var charOffset = coords[0] - startIndex;\n        var leftWideCharCount = 0;\n        var rightWideCharCount = 0;\n        if (line.charAt(startIndex) === ' ') {\n            while (startIndex > 0 && line.charAt(startIndex - 1) === ' ') {\n                startIndex--;\n            }\n            while (endIndex < line.length && line.charAt(endIndex + 1) === ' ') {\n                endIndex++;\n            }\n        }\n        else {\n            var startCol = coords[0];\n            var endCol = coords[0];\n            if (bufferLine[startCol][LINE_DATA_WIDTH_INDEX] === 0) {\n                leftWideCharCount++;\n                startCol--;\n            }\n            if (bufferLine[endCol][LINE_DATA_WIDTH_INDEX] === 2) {\n                rightWideCharCount++;\n                endCol++;\n            }\n            while (startIndex > 0 && !this._isCharWordSeparator(line.charAt(startIndex - 1))) {\n                if (bufferLine[startCol - 1][LINE_DATA_WIDTH_INDEX] === 0) {\n                    leftWideCharCount++;\n                    startCol--;\n                }\n                startIndex--;\n                startCol--;\n            }\n            while (endIndex + 1 < line.length && !this._isCharWordSeparator(line.charAt(endIndex + 1))) {\n                if (bufferLine[endCol + 1][LINE_DATA_WIDTH_INDEX] === 2) {\n                    rightWideCharCount++;\n                    endCol++;\n                }\n                endIndex++;\n                endCol++;\n            }\n        }\n        var start = startIndex + charOffset - leftWideCharCount;\n        var length = Math.min(endIndex - startIndex + leftWideCharCount + rightWideCharCount + 1, this._terminal.cols);\n        return { start: start, length: length };\n    };\n    SelectionManager.prototype._selectWordAt = function (coords) {\n        var wordPosition = this._getWordAt(coords);\n        this._model.selectionStart = [wordPosition.start, coords[1]];\n        this._model.selectionStartLength = wordPosition.length;\n    };\n    SelectionManager.prototype._selectToWordAt = function (coords) {\n        var wordPosition = this._getWordAt(coords);\n        this._model.selectionEnd = [this._model.areSelectionValuesReversed() ? wordPosition.start : (wordPosition.start + wordPosition.length), coords[1]];\n    };\n    SelectionManager.prototype._isCharWordSeparator = function (char) {\n        return WORD_SEPARATORS.indexOf(char) >= 0;\n    };\n    SelectionManager.prototype._selectLineAt = function (line) {\n        this._model.selectionStart = [0, line];\n        this._model.selectionStartLength = this._terminal.cols;\n    };\n    return SelectionManager;\n}(EventEmitter_1.EventEmitter));\nexports.SelectionManager = SelectionManager;\n\n\n"},"sourceMaps":{"js":{"version":3,"sources":["../src/SelectionManager.ts"],"names":[],"mappings":"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","file":"SelectionManager.js","sourceRoot":".","sourcesContent":["/**\n * @license MIT\n */\n\nimport * as Mouse from './utils/Mouse';\nimport * as Browser from './utils/Browser';\nimport { CharMeasure } from './utils/CharMeasure';\nimport { CircularList } from './utils/CircularList';\nimport { EventEmitter } from './EventEmitter';\nimport { ITerminal } from './Interfaces';\nimport { SelectionModel } from './SelectionModel';\n\n/**\n * The number of pixels the mouse needs to be above or below the viewport in\n * order to scroll at the maximum speed.\n */\nconst DRAG_SCROLL_MAX_THRESHOLD = 50;\n\n/**\n * The maximum scrolling speed\n */\nconst DRAG_SCROLL_MAX_SPEED = 15;\n\n/**\n * The number of milliseconds between drag scroll updates.\n */\nconst DRAG_SCROLL_INTERVAL = 50;\n\n/**\n * The amount of time before mousedown events are no longer stacked to create\n * double/triple click events.\n */\nconst CLEAR_MOUSE_DOWN_TIME = 400;\n\n/**\n * The number of pixels in each direction that the mouse must move before\n * mousedown events are no longer stacked to create double/triple click events.\n */\nconst CLEAR_MOUSE_DISTANCE = 10;\n\n/**\n * A string containing all characters that are considered word separated by the\n * double click to select work logic.\n */\nconst WORD_SEPARATORS = ' ()[]{}\\'\"';\n\n// TODO: Move these constants elsewhere, they belong in a buffer or buffer\n//       data/line class.\nconst LINE_DATA_CHAR_INDEX = 1;\nconst LINE_DATA_WIDTH_INDEX = 2;\n\nconst NON_BREAKING_SPACE_CHAR = String.fromCharCode(160);\nconst ALL_NON_BREAKING_SPACE_REGEX = new RegExp(NON_BREAKING_SPACE_CHAR, 'g');\n\n/**\n * Represents a position of a word on a line.\n */\ninterface IWordPosition {\n  start: number;\n  length: number;\n}\n\n/**\n * A selection mode, this drives how the selection behaves on mouse move.\n */\nenum SelectionMode {\n  NORMAL,\n  WORD,\n  LINE\n}\n\n/**\n * A class that manages the selection of the terminal. With help from\n * SelectionModel, SelectionManager handles with all logic associated with\n * dealing with the selection, including handling mouse interaction, wide\n * characters and fetching the actual text within the selection. Rendering is\n * not handled by the SelectionManager but a 'refresh' event is fired when the\n * selection is ready to be redrawn.\n */\nexport class SelectionManager extends EventEmitter {\n  protected _model: SelectionModel;\n\n  /**\n   * The amount to scroll every drag scroll update (depends on how far the mouse\n   * drag is above or below the terminal).\n   */\n  private _dragScrollAmount: number;\n\n  /**\n   * The last time the mousedown event fired, this is used to track double and\n   * triple clicks.\n   */\n  private _lastMouseDownTime: number;\n\n  /**\n   * The last position the mouse was clicked [x, y].\n   */\n  private _lastMousePosition: [number, number];\n\n  /**\n   * The number of clicks of the mousedown event. This is used to keep track of\n   * double and triple clicks.\n   */\n  private _clickCount: number;\n\n  /**\n   * The current selection mode.\n   */\n  private _activeSelectionMode: SelectionMode;\n\n  /**\n   * A setInterval timer that is active while the mouse is down whose callback\n   * scrolls the viewport when necessary.\n   */\n  private _dragScrollIntervalTimer: NodeJS.Timer;\n\n  /**\n   * The animation frame ID used for refreshing the selection.\n   */\n  private _refreshAnimationFrame: number;\n\n  private _bufferTrimListener: any;\n  private _mouseMoveListener: EventListener;\n  private _mouseDownListener: EventListener;\n  private _mouseUpListener: EventListener;\n\n  constructor(\n    private _terminal: ITerminal,\n    private _buffer: CircularList<any>,\n    private _rowContainer: HTMLElement,\n    private _charMeasure: CharMeasure\n  ) {\n    super();\n    this._initListeners();\n    this.enable();\n\n    this._model = new SelectionModel(_terminal);\n    this._lastMouseDownTime = 0;\n    this._activeSelectionMode = SelectionMode.NORMAL;\n  }\n\n  /**\n   * Initializes listener variables.\n   */\n  private _initListeners() {\n    this._bufferTrimListener = (amount: number) => this._onTrim(amount);\n    this._mouseMoveListener = event => this._onMouseMove(<MouseEvent>event);\n    this._mouseDownListener = event => this._onMouseDown(<MouseEvent>event);\n    this._mouseUpListener = event => this._onMouseUp(<MouseEvent>event);\n  }\n\n  /**\n   * Disables the selection manager. This is useful for when terminal mouse\n   * are enabled.\n   */\n  public disable() {\n    this.clearSelection();\n    this._buffer.off('trim', this._bufferTrimListener);\n    this._rowContainer.removeEventListener('mousedown', this._mouseDownListener);\n  }\n\n  /**\n   * Enable the selection manager.\n   */\n  public enable() {\n    // Only adjust the selection on trim, shiftElements is rarely used (only in\n    // reverseIndex) and delete in a splice is only ever used when the same\n    // number of elements was just added. Given this is could actually be\n    // beneficial to leave the selection as is for these cases.\n    this._buffer.on('trim', this._bufferTrimListener);\n    this._rowContainer.addEventListener('mousedown', this._mouseDownListener);\n  }\n\n  /**\n   * Sets the active buffer, this should be called when the alt buffer is\n   * switched in or out.\n   * @param buffer The active buffer.\n   */\n  public setBuffer(buffer: CircularList<any>): void {\n    this._buffer = buffer;\n    this.clearSelection();\n  }\n\n  /**\n   * Gets whether there is an active text selection.\n   */\n  public get hasSelection(): boolean {\n    const start = this._model.finalSelectionStart;\n    const end = this._model.finalSelectionEnd;\n    if (!start || !end) {\n      return false;\n    }\n    return start[0] !== end[0] || start[1] !== end[1];\n  }\n\n  /**\n   * Gets the text currently selected.\n   */\n  public get selectionText(): string {\n    const start = this._model.finalSelectionStart;\n    const end = this._model.finalSelectionEnd;\n    if (!start || !end) {\n      return '';\n    }\n\n    // Get first row\n    const startRowEndCol = start[1] === end[1] ? end[0] : null;\n    let result: string[] = [];\n    result.push(this._translateBufferLineToString(this._buffer.get(start[1]), true, start[0], startRowEndCol));\n\n    // Get middle rows\n    for (let i = start[1] + 1; i <= end[1] - 1; i++) {\n      const bufferLine = this._buffer.get(i);\n      const lineText = this._translateBufferLineToString(bufferLine, true);\n      if (bufferLine.isWrapped) {\n        result[result.length - 1] += lineText;\n      } else {\n        result.push(lineText);\n      }\n    }\n\n    // Get final row\n    if (start[1] !== end[1]) {\n      const bufferLine = this._buffer.get(end[1]);\n      const lineText = this._translateBufferLineToString(bufferLine, true, 0, end[0]);\n      if (bufferLine.isWrapped) {\n        result[result.length - 1] += lineText;\n      } else {\n        result.push(lineText);\n      }\n    }\n\n    // Format string by replacing non-breaking space chars with regular spaces\n    // and joining the array into a multi-line string.\n    const formattedResult = result.map(line => {\n      return line.replace(ALL_NON_BREAKING_SPACE_REGEX, ' ');\n    }).join(Browser.isMSWindows ? '\\r\\n' : '\\n');\n\n    return formattedResult;\n  }\n\n  /**\n   * Clears the current terminal selection.\n   */\n  public clearSelection(): void {\n    this._model.clearSelection();\n    this._removeMouseDownListeners();\n    this.refresh();\n  }\n\n  /**\n   * Translates a buffer line to a string, with optional start and end columns.\n   * Wide characters will count as two columns in the resulting string. This\n   * function is useful for getting the actual text underneath the raw selection\n   * position.\n   * @param line The line being translated.\n   * @param trimRight Whether to trim whitespace to the right.\n   * @param startCol The column to start at.\n   * @param endCol The column to end at.\n   */\n  private _translateBufferLineToString(line: any, trimRight: boolean, startCol: number = 0, endCol: number = null): string {\n    // TODO: This function should live in a buffer or buffer line class\n\n    // Get full line\n    let lineString = '';\n    let widthAdjustedStartCol = startCol;\n    let widthAdjustedEndCol = endCol;\n    for (let i = 0; i < line.length; i++) {\n      const char = line[i];\n      lineString += char[LINE_DATA_CHAR_INDEX];\n      // Adjust start and end cols for wide characters if they affect their\n      // column indexes\n      if (char[LINE_DATA_WIDTH_INDEX] === 0) {\n        if (startCol >= i) {\n          widthAdjustedStartCol--;\n        }\n        if (endCol >= i) {\n          widthAdjustedEndCol--;\n        }\n      }\n    }\n\n    // Calculate the final end col by trimming whitespace on the right of the\n    // line if needed.\n    let finalEndCol = widthAdjustedEndCol || line.length;\n    if (trimRight) {\n      const rightWhitespaceIndex = lineString.search(/\\s+$/);\n      if (rightWhitespaceIndex !== -1) {\n        finalEndCol = Math.min(finalEndCol, rightWhitespaceIndex);\n      }\n      // Return the empty string if only trimmed whitespace is selected\n      if (finalEndCol <= widthAdjustedStartCol) {\n        return '';\n      }\n    }\n\n    return lineString.substring(widthAdjustedStartCol, finalEndCol);\n  }\n\n  /**\n   * Queues a refresh, redrawing the selection on the next opportunity.\n   * @param isNewSelection Whether the selection should be registered as a new\n   * selection on Linux.\n   */\n  public refresh(isNewSelection?: boolean): void {\n    // Queue the refresh for the renderer\n    if (!this._refreshAnimationFrame) {\n      this._refreshAnimationFrame = window.requestAnimationFrame(() => this._refresh());\n    }\n\n    // If the platform is Linux and the refresh call comes from a mouse event,\n    // we need to update the selection for middle click to paste selection.\n    if (Browser.isLinux && isNewSelection) {\n      const selectionText = this.selectionText;\n      if (selectionText.length) {\n        this.emit('newselection', this.selectionText);\n      }\n    }\n  }\n\n  /**\n   * Fires the refresh event, causing consumers to pick it up and redraw the\n   * selection state.\n   */\n  private _refresh(): void {\n    this._refreshAnimationFrame = null;\n    this.emit('refresh', { start: this._model.finalSelectionStart, end: this._model.finalSelectionEnd });\n  }\n\n  /**\n   * Selects all text within the terminal.\n   */\n  public selectAll(): void {\n    this._model.isSelectAllActive = true;\n    this.refresh();\n  }\n\n  /**\n   * Handle the buffer being trimmed, adjust the selection position.\n   * @param amount The amount the buffer is being trimmed.\n   */\n  private _onTrim(amount: number) {\n    const needsRefresh = this._model.onTrim(amount);\n    if (needsRefresh) {\n      this.refresh();\n    }\n  }\n\n  /**\n   * Gets the 0-based [x, y] buffer coordinates of the current mouse event.\n   * @param event The mouse event.\n   */\n  private _getMouseBufferCoords(event: MouseEvent): [number, number] {\n    const coords = Mouse.getCoords(event, this._rowContainer, this._charMeasure, this._terminal.cols, this._terminal.rows, true);\n    // Convert to 0-based\n    coords[0]--;\n    coords[1]--;\n    // Convert viewport coords to buffer coords\n    coords[1] += this._terminal.ydisp;\n    return coords;\n  }\n\n  /**\n   * Gets the amount the viewport should be scrolled based on how far out of the\n   * terminal the mouse is.\n   * @param event The mouse event.\n   */\n  private _getMouseEventScrollAmount(event: MouseEvent): number {\n    let offset = Mouse.getCoordsRelativeToElement(event, this._rowContainer)[1];\n    const terminalHeight = this._terminal.rows * this._charMeasure.height;\n    if (offset >= 0 && offset <= terminalHeight) {\n      return 0;\n    }\n    if (offset > terminalHeight) {\n      offset -= terminalHeight;\n    }\n\n    offset = Math.min(Math.max(offset, -DRAG_SCROLL_MAX_THRESHOLD), DRAG_SCROLL_MAX_THRESHOLD);\n    offset /= DRAG_SCROLL_MAX_THRESHOLD;\n    return (offset / Math.abs(offset)) + Math.round(offset * (DRAG_SCROLL_MAX_SPEED - 1));\n  }\n\n  /**\n   * Handles te mousedown event, setting up for a new selection.\n   * @param event The mousedown event.\n   */\n  private _onMouseDown(event: MouseEvent) {\n    // Only action the primary button\n    if (event.button !== 0) {\n      return;\n    }\n\n    // Tell the browser not to start a regular selection\n    event.preventDefault();\n\n    // Reset drag scroll state\n    this._dragScrollAmount = 0;\n\n    this._setMouseClickCount(event);\n\n    if (event.shiftKey) {\n      this._onShiftClick(event);\n    } else {\n      if (this._clickCount === 1) {\n          this._onSingleClick(event);\n      } else if (this._clickCount === 2) {\n          this._onDoubleClick(event);\n      } else if (this._clickCount === 3) {\n          this._onTripleClick(event);\n      }\n    }\n\n    this._addMouseDownListeners();\n    this.refresh(true);\n  }\n\n  /**\n   * Adds listeners when mousedown is triggered.\n   */\n  private _addMouseDownListeners(): void {\n    // Listen on the document so that dragging outside of viewport works\n    this._rowContainer.ownerDocument.addEventListener('mousemove', this._mouseMoveListener);\n    this._rowContainer.ownerDocument.addEventListener('mouseup', this._mouseUpListener);\n    this._dragScrollIntervalTimer = setInterval(() => this._dragScroll(), DRAG_SCROLL_INTERVAL);\n  }\n\n  /**\n   * Removes the listeners that are registered when mousedown is triggered.\n   */\n  private _removeMouseDownListeners(): void {\n    this._rowContainer.ownerDocument.removeEventListener('mousemove', this._mouseMoveListener);\n    this._rowContainer.ownerDocument.removeEventListener('mouseup', this._mouseUpListener);\n    clearInterval(this._dragScrollIntervalTimer);\n    this._dragScrollIntervalTimer = null;\n  }\n\n  /**\n   * Performs a shift click, setting the selection end position to the mouse\n   * position.\n   * @param event The mouse event.\n   */\n  private _onShiftClick(event: MouseEvent): void {\n    if (this._model.selectionStart) {\n      this._model.selectionEnd = this._getMouseBufferCoords(event);\n    }\n  }\n\n  /**\n   * Performs a single click, resetting relevant state and setting the selection\n   * start position.\n   * @param event The mouse event.\n   */\n  private _onSingleClick(event: MouseEvent): void {\n    this._model.selectionStartLength = 0;\n    this._model.isSelectAllActive = false;\n    this._activeSelectionMode = SelectionMode.NORMAL;\n    this._model.selectionStart = this._getMouseBufferCoords(event);\n    if (this._model.selectionStart) {\n      this._model.selectionEnd = null;\n      // If the mouse is over the second half of a wide character, adjust the\n      // selection to cover the whole character\n      const char = this._buffer.get(this._model.selectionStart[1])[this._model.selectionStart[0]];\n      if (char[LINE_DATA_WIDTH_INDEX] === 0) {\n        this._model.selectionStart[0]++;\n      }\n    }\n  }\n\n  /**\n   * Performs a double click, selecting the current work.\n   * @param event The mouse event.\n   */\n  private _onDoubleClick(event: MouseEvent): void {\n    const coords = this._getMouseBufferCoords(event);\n    if (coords) {\n      this._activeSelectionMode = SelectionMode.WORD;\n      this._selectWordAt(coords);\n    }\n  }\n\n  /**\n   * Performs a triple click, selecting the current line and activating line\n   * select mode.\n   * @param event The mouse event.\n   */\n  private _onTripleClick(event: MouseEvent): void {\n    const coords = this._getMouseBufferCoords(event);\n    if (coords) {\n      this._activeSelectionMode = SelectionMode.LINE;\n      this._selectLineAt(coords[1]);\n    }\n  }\n\n  /**\n   * Sets the number of clicks for the current mousedown event based on the time\n   * and position of the last mousedown event.\n   * @param event The mouse event.\n   */\n  private _setMouseClickCount(event: MouseEvent): void {\n    let currentTime = (new Date()).getTime();\n    if (currentTime - this._lastMouseDownTime > CLEAR_MOUSE_DOWN_TIME || this._distanceFromLastMousePosition(event) > CLEAR_MOUSE_DISTANCE) {\n      this._clickCount = 0;\n    }\n    this._lastMouseDownTime = currentTime;\n    this._lastMousePosition = [event.pageX, event.pageY];\n    this._clickCount++;\n  }\n\n  /**\n   * Gets the maximum number of pixels in each direction the mouse has moved.\n   * @param event The mouse event.\n   */\n  private _distanceFromLastMousePosition(event: MouseEvent): number {\n    const result = Math.max(\n        Math.abs(this._lastMousePosition[0] - event.pageX),\n        Math.abs(this._lastMousePosition[1] - event.pageY));\n    return result;\n  }\n\n  /**\n   * Handles the mousemove event when the mouse button is down, recording the\n   * end of the selection and refreshing the selection.\n   * @param event The mousemove event.\n   */\n  private _onMouseMove(event: MouseEvent) {\n    // Record the previous position so we know whether to redraw the selection\n    // at the end.\n    const previousSelectionEnd = this._model.selectionEnd ? [this._model.selectionEnd[0], this._model.selectionEnd[1]] : null;\n\n    // Set the initial selection end based on the mouse coordinates\n    this._model.selectionEnd = this._getMouseBufferCoords(event);\n\n    // Select the entire line if line select mode is active.\n    if (this._activeSelectionMode === SelectionMode.LINE) {\n      if (this._model.selectionEnd[1] < this._model.selectionStart[1]) {\n        this._model.selectionEnd[0] = 0;\n      } else {\n        this._model.selectionEnd[0] = this._terminal.cols;\n      }\n    } else if (this._activeSelectionMode === SelectionMode.WORD) {\n      this._selectToWordAt(this._model.selectionEnd);\n    }\n\n    // Determine the amount of scrolling that will happen.\n    this._dragScrollAmount = this._getMouseEventScrollAmount(event);\n\n    // If the cursor was above or below the viewport, make sure it's at the\n    // start or end of the viewport respectively.\n    if (this._dragScrollAmount > 0) {\n      this._model.selectionEnd[0] = this._terminal.cols - 1;\n    } else if (this._dragScrollAmount < 0) {\n      this._model.selectionEnd[0] = 0;\n    }\n\n    // If the character is a wide character include the cell to the right in the\n    // selection. Note that selections at the very end of the line will never\n    // have a character.\n    if (this._model.selectionEnd[1] < this._buffer.length) {\n      const char = this._buffer.get(this._model.selectionEnd[1])[this._model.selectionEnd[0]];\n      if (char && char[2] === 0) {\n        this._model.selectionEnd[0]++;\n      }\n    }\n\n    // Only draw here if the selection changes.\n    if (!previousSelectionEnd ||\n        previousSelectionEnd[0] !== this._model.selectionEnd[0] ||\n        previousSelectionEnd[1] !== this._model.selectionEnd[1]) {\n      this.refresh(true);\n    }\n  }\n\n  /**\n   * The callback that occurs every DRAG_SCROLL_INTERVAL ms that does the\n   * scrolling of the viewport.\n   */\n  private _dragScroll() {\n    if (this._dragScrollAmount) {\n      this._terminal.scrollDisp(this._dragScrollAmount, false);\n      // Re-evaluate selection\n      if (this._dragScrollAmount > 0) {\n        this._model.selectionEnd = [this._terminal.cols - 1, this._terminal.ydisp + this._terminal.rows];\n      } else {\n        this._model.selectionEnd = [0, this._terminal.ydisp];\n      }\n      this.refresh();\n    }\n  }\n\n  /**\n   * Handles the mouseup event, removing the mousedown listeners.\n   * @param event The mouseup event.\n   */\n  private _onMouseUp(event: MouseEvent) {\n    this._removeMouseDownListeners();\n  }\n\n  /**\n   * Converts a viewport column to the character index on the buffer line, the\n   * latter takes into account wide characters.\n   * @param coords The coordinates to find the 2 index for.\n   */\n  private _convertViewportColToCharacterIndex(bufferLine: any, coords: [number, number]): number {\n    let charIndex = coords[0];\n    for (let i = 0; coords[0] >= i; i++) {\n      const char = bufferLine[i];\n      if (char[LINE_DATA_WIDTH_INDEX] === 0) {\n        charIndex--;\n      }\n    }\n    return charIndex;\n  }\n\n  /**\n   * Gets positional information for the word at the coordinated specified.\n   * @param coords The coordinates to get the word at.\n   */\n  private _getWordAt(coords: [number, number]): IWordPosition {\n    const bufferLine = this._buffer.get(coords[1]);\n    const line = this._translateBufferLineToString(bufferLine, false);\n\n    // Get actual index, taking into consideration wide characters\n    let endIndex = this._convertViewportColToCharacterIndex(bufferLine, coords);\n    let startIndex = endIndex;\n\n    // Record offset to be used later\n    const charOffset = coords[0] - startIndex;\n    let leftWideCharCount = 0;\n    let rightWideCharCount = 0;\n\n    if (line.charAt(startIndex) === ' ') {\n      // Expand until non-whitespace is hit\n      while (startIndex > 0 && line.charAt(startIndex - 1) === ' ') {\n        startIndex--;\n      }\n      while (endIndex < line.length && line.charAt(endIndex + 1) === ' ') {\n        endIndex++;\n      }\n    } else {\n      // Expand until whitespace is hit. This algorithm works by scanning left\n      // and right from the starting position, keeping both the index format\n      // (line) and the column format (bufferLine) in sync. When a wide\n      // character is hit, it is recorded and the column index is adjusted.\n      let startCol = coords[0];\n      let endCol = coords[0];\n      // Consider the initial position, skip it and increment the wide char\n      // variable\n      if (bufferLine[startCol][LINE_DATA_WIDTH_INDEX] === 0) {\n        leftWideCharCount++;\n        startCol--;\n      }\n      if (bufferLine[endCol][LINE_DATA_WIDTH_INDEX] === 2) {\n        rightWideCharCount++;\n        endCol++;\n      }\n      // Expand the string in both directions until a space is hit\n      while (startIndex > 0 && !this._isCharWordSeparator(line.charAt(startIndex - 1))) {\n        if (bufferLine[startCol - 1][LINE_DATA_WIDTH_INDEX] === 0) {\n          // If the next character is a wide char, record it and skip the column\n          leftWideCharCount++;\n          startCol--;\n        }\n        startIndex--;\n        startCol--;\n      }\n      while (endIndex + 1 < line.length && !this._isCharWordSeparator(line.charAt(endIndex + 1))) {\n        if (bufferLine[endCol + 1][LINE_DATA_WIDTH_INDEX] === 2) {\n          // If the next character is a wide char, record it and skip the column\n          rightWideCharCount++;\n          endCol++;\n        }\n        endIndex++;\n        endCol++;\n      }\n    }\n\n    const start = startIndex + charOffset - leftWideCharCount;\n    const length = Math.min(endIndex - startIndex + leftWideCharCount + rightWideCharCount + 1/*include endIndex char*/, this._terminal.cols);\n    return {start, length};\n  }\n\n  /**\n   * Selects the word at the coordinates specified.\n   * @param coords The coordinates to get the word at.\n   */\n  protected _selectWordAt(coords: [number, number]): void {\n    const wordPosition = this._getWordAt(coords);\n    this._model.selectionStart = [wordPosition.start, coords[1]];\n    this._model.selectionStartLength = wordPosition.length;\n  }\n\n  /**\n   * Sets the selection end to the word at the coordinated specified.\n   * @param coords The coordinates to get the word at.\n   */\n  private _selectToWordAt(coords: [number, number]): void {\n    const wordPosition = this._getWordAt(coords);\n    this._model.selectionEnd = [this._model.areSelectionValuesReversed() ? wordPosition.start : (wordPosition.start + wordPosition.length), coords[1]];\n  }\n\n  /**\n   * Gets whether the character is considered a word separator by the select\n   * word logic.\n   * @param char The character to check.\n   */\n  private _isCharWordSeparator(char: string): boolean {\n    return WORD_SEPARATORS.indexOf(char) >= 0;\n  }\n\n  /**\n   * Selects the line specified.\n   * @param line The line index.\n   */\n  protected _selectLineAt(line: number): void {\n    this._model.selectionStart = [0, line];\n    this._model.selectionStartLength = this._terminal.cols;\n  }\n}\n"]}},"error":null,"hash":"143fcb6ece18808d92a497bf2718ea3c","cacheData":{"env":{}}}